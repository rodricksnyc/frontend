"use strict";

require("core-js/modules/es.array.index-of.js");

require("core-js/modules/es.array.filter.js");

require("core-js/modules/es.object.get-own-property-descriptors.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.weak-map.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Query = void 0;

require("core-js/modules/es.array.from.js");

var _react = _interopRequireWildcard(require("react"));

var _values = _interopRequireDefault(require("lodash/values"));

var _get = _interopRequireDefault(require("lodash/get"));

var _utils = require("../utils");

var _QueryContext = require("./QueryContext");

const _excluded = ["runCount"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const initialAsyncState = {
  fetchQueryId: {
    loading: false,
    responseOk: true,
    runCount: 0
  },
  fetchQueryResult: {
    loading: false,
    responseOk: true,
    runCount: 0
  },
  fetchVisConfig: {
    loading: false,
    responseOk: true,
    runCount: 0
  }
};

function asyncStateReducer(state, action) {
  switch (action.type) {
    case 'reset':
      return initialAsyncState;

    case 'update':
      {
        const value = action.value,
              name = action.name;

        const _state$name = state[name],
              runCount = _state$name.runCount,
              currentState = _objectWithoutProperties(_state$name, _excluded);

        return _objectSpread(_objectSpread({}, state), {}, {
          [name]: _objectSpread(_objectSpread({}, currentState), {}, {
            runCount: runCount + 1
          }, value)
        });
      }
  }
}

const initialDataState = {
  queryId: null,
  data: null,
  visConfig: null,
  fields: null,
  pivots: null,
  shareUrl: null,
  totals: null
};

function dataStateReducer(state, action) {
  switch (action.type) {
    case 'reset':
      return initialDataState;

    case 'update':
      return _objectSpread(_objectSpread({}, state), action.value);
  }
}

const Query = ({
  query,
  children,
  sdk,
  config: configOverrides
}) => {
  var _fields$measures;

  const _useState = (0, _react.useState)(),
        _useState2 = _slicedToArray(_useState, 2),
        error = _useState2[0],
        setError = _useState2[1];

  const _useReducer = (0, _react.useReducer)(dataStateReducer, initialDataState),
        _useReducer2 = _slicedToArray(_useReducer, 2),
        dataState = _useReducer2[0],
        dispatchDataReducer = _useReducer2[1];

  const _useReducer3 = (0, _react.useReducer)(asyncStateReducer, initialAsyncState),
        _useReducer4 = _slicedToArray(_useReducer3, 2),
        asyncState = _useReducer4[0],
        dispatchAsyncReducer = _useReducer4[1];

  const data = dataState.data,
        fields = dataState.fields,
        pivots = dataState.pivots,
        totals = dataState.totals,
        visConfig = dataState.visConfig,
        shareUrl = dataState.shareUrl,
        queryId = dataState.queryId;

  if ((0, _utils.isNumeric)(query) && !queryId) {
    dispatchDataReducer({
      type: 'update',
      value: {
        queryId: Number(query)
      }
    });
  }

  const isLoading = (0, _values.default)(asyncState).some(v => v.loading === true);
  const isEveryResponseOk = (0, _values.default)(asyncState).every(v => v.responseOk === true);
  const isDataShapeValid = Boolean(fields === null || fields === void 0 ? void 0 : (_fields$measures = fields.measures) === null || _fields$measures === void 0 ? void 0 : _fields$measures.length);
  const isDataValid = isEveryResponseOk && (data === null || data === void 0 ? void 0 : data.length) && isDataShapeValid;
  (0, _react.useEffect)(() => {
    dispatchAsyncReducer({
      type: 'reset'
    });
    dispatchDataReducer({
      type: 'reset'
    });
  }, [query, sdk]);
  const asyncLifecycle = (0, _react.useCallback)(function () {
    var _ref = _asyncToGenerator(function* (name, request) {
      if (asyncState[name].loading !== true && asyncState[name].runCount === 0 && isEveryResponseOk) {
        dispatchAsyncReducer({
          type: 'update',
          name,
          value: {
            loading: true
          }
        });

        try {
          yield request();
        } catch (error) {
          if (!(error instanceof Error)) throw error;
          dispatchAsyncReducer({
            type: 'update',
            name,
            value: {
              responseOk: false
            }
          });
          setError(_objectSpread(_objectSpread({}, error), {}, {
            documentation_url: 'https://docs.looker.com',
            message: `${name}: ${error.message}`
          }));
        }

        dispatchAsyncReducer({
          type: 'update',
          name,
          value: {
            loading: false
          }
        });
      }
    });

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }(), [dispatchAsyncReducer, setError, asyncState, isEveryResponseOk]);
  (0, _react.useEffect)(() => {
    const fetchQueryId = function () {
      var _ref2 = _asyncToGenerator(function* (slug) {
        const result = yield sdk.query_for_slug(slug, 'id, vis_config, share_url');

        if (result.ok === false) {
          dispatchAsyncReducer({
            type: 'update',
            name: 'fetchQueryId',
            value: {
              responseOk: false
            }
          });
        }

        if ('value' in result) {
          const value = result.value;

          if ('vis_config' in value) {
            dispatchDataReducer({
              type: 'update',
              value: {
                visConfig: value.vis_config
              }
            });
          }

          if ('id' in value) {
            dispatchDataReducer({
              type: 'update',
              value: {
                queryId: Number(value.id)
              }
            });
          }

          if ('share_url' in value) {
            dispatchDataReducer({
              type: 'update',
              value: {
                shareUrl: String(value.share_url)
              }
            });
          }
        } else {
          setError(_objectSpread(_objectSpread({}, error), result.error));
        }
      });

      return function fetchQueryId(_x3) {
        return _ref2.apply(this, arguments);
      };
    }();

    if (query && !queryId) {
      asyncLifecycle('fetchQueryId', () => fetchQueryId(query));
    }
  }, [query, error, asyncLifecycle, queryId, sdk]);
  (0, _react.useEffect)(() => {
    const fetchQueryResult = function () {
      var _ref3 = _asyncToGenerator(function* (id) {
        const queryArgs = {
          query_id: id,
          result_format: 'json_detail'
        };
        const result = yield sdk.run_query(queryArgs);
        dispatchAsyncReducer({
          type: 'update',
          name: 'fetchQueryResult',
          value: {
            responseOk: result.ok
          }
        });

        if (result.ok === false && result.error) {
          result.error = _objectSpread(_objectSpread({}, result.error), queryArgs);
          setError(result.error);
        } else if (result.ok === true && result.value) {
          const _value = result.value,
                data = _value.data,
                fields = _value.fields,
                pivots = _value.pivots,
                totals_data = _value.totals_data;
          dispatchDataReducer({
            type: 'update',
            value: {
              data,
              fields,
              pivots,
              totals: totals_data
            }
          });
        }
      });

      return function fetchQueryResult(_x4) {
        return _ref3.apply(this, arguments);
      };
    }();

    const fetchVisConfig = function () {
      var _ref4 = _asyncToGenerator(function* (id) {
        const config = yield sdk.query(id, 'vis_config, share_url');
        const visConfig = (0, _get.default)(config, 'value.vis_config');
        const shareUrl = (0, _get.default)(config, 'value.share_url');

        if (visConfig) {
          dispatchDataReducer({
            type: 'update',
            value: {
              visConfig
            }
          });
        } else {
          dispatchAsyncReducer({
            type: 'update',
            name: 'fetchVisConfig',
            value: {
              responseOk: false
            }
          });
        }

        if (shareUrl) {
          dispatchDataReducer({
            type: 'update',
            value: {
              shareUrl
            }
          });
        }
      });

      return function fetchVisConfig(_x5) {
        return _ref4.apply(this, arguments);
      };
    }();

    if (!!queryId && !data) {
      asyncLifecycle('fetchQueryResult', () => fetchQueryResult(queryId));
    }

    if (!!queryId && !visConfig) {
      asyncLifecycle('fetchVisConfig', () => fetchVisConfig(queryId));
    }
  }, [queryId, visConfig, data, asyncLifecycle, sdk]);
  let dataCopy = [];
  let fieldsCopy = {
    dimensions: [],
    measures: []
  };

  if (isDataValid && fields) {
    dataCopy = pivots ? (0, _utils.tabularPivotResponse)({
      data,
      fields,
      pivots
    }) : (0, _utils.tabularResponse)(Array.from(data));
    fieldsCopy = pivots ? (0, _utils.buildPivotFields)({
      fields,
      pivots
    }) : fields;
  }

  return _react.default.createElement(_QueryContext.QueryContext.Provider, {
    value: {
      config: _objectSpread(_objectSpread({}, visConfig), configOverrides),
      data: dataCopy,
      error,
      fields: fieldsCopy,
      loading: isLoading,
      ok: isEveryResponseOk,
      shareUrl: shareUrl || undefined,
      totals: totals || undefined
    }
  }, children);
};

exports.Query = Query;
//# sourceMappingURL=Query.js.map